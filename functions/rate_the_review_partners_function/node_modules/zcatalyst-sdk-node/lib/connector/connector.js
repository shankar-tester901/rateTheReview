'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CatalystAppInternals = require('../catalyst-app').CatalystAppInternals;
var CatalystConnectorError = require('../utils/error').CatalystConnectorError;
var validator = require('../utils/validator');
var constants = require('../utils/constants');
var Connector = /** @class */ (function (_super) {
    __extends(Connector, _super);
    function Connector(connectorDetails, connectionInstance) {
        var _this = _super.call(this, connectionInstance) || this;
        _this.connectorName = connectorDetails[constants.CONNECTOR_NAME];
        _this.authUrl = connectorDetails[constants.AUTH_URL];
        _this.refreshUrl = connectorDetails[constants.REFRESH_URL];
        _this.refreshToken = connectorDetails[constants.REFRESH_TOKEN];
        _this.clientId = connectorDetails[constants.CLIENT_ID];
        _this.clientSecret = connectorDetails[constants.CLIENT_SECRET];
        _this.expiresIn = connectorDetails[constants.EXPIRES_IN];
        _this.redirectUrl = connectorDetails[constants.REDIRECT_URL];
        _this.accessToken = null;
        _this.app = connectionInstance.app;
        _this.requester = connectionInstance.requester;
        return _this;
    }
    Connector.prototype.getAccessToken = function () {
        var _this = this;
        return this.app
            .cache()
            .segment()
            .get(this._connectorName)
            .then(function (cachedTokenObj) {
            var value = cachedTokenObj.cache_value;
            if (value === null) {
                return _this.refreshAndPersistToken();
            }
            var remainingTime = cachedTokenObj.ttl_in_milliseconds;
            var actualTime = 3600000;
            var time = actualTime - remainingTime;
            if (time > _this.expiresIn * 1000) {
                return _this.refreshAndPersistToken();
            }
            return value;
        });
    };
    Connector.prototype.generateAccessToken = function (code) {
        var _this = this;
        return validator
            .wrapValidatorsWithPromise(function () {
            validator.isNonEmptyString(code, 'grant_token', true);
            validator.isNonEmptyString(code, constants.REDIRECT_URL, true);
        }, CatalystConnectorError)
            .then(function () {
            var _a;
            var request = {
                method: 'POST',
                url: _this.authUrl,
                data: (_a = {},
                    _a[constants.GRANT_TYPE] = 'authorization_code',
                    _a[constants.CODE] = code,
                    _a[constants.CLIENT_ID] = _this.clientId,
                    _a[constants.CLIENT_SECRET] = _this.clientSecret,
                    _a[constants.REDIRECT_URL] = _this.redirectUrl,
                    _a)
            };
            return _this.requester.send(request);
        })
            .then(function (resp) {
            var tokenObj = resp.data;
            return validator
                .wrapValidatorsWithPromise(function () {
                validator.isNonNullObject(tokenObj, 'auth_response', true);
                validator.validateObject(tokenObj, [constants.ACCESS_TOKEN, constants.REFRESH_TOKEN, constants.EXPIRES_IN], 'auth_response', true);
            }, CatalystConnectorError)
                .then(function () { return tokenObj; });
        })
            .then(function (authResponse) {
            _this.accessToken = authResponse[constants.ACCESS_TOKEN];
            _this.refreshToken = authResponse[constants.REFRESH_TOKEN];
            _this.expiresIn = authResponse[constants.EXPIRES_IN];
            return _this.putAccessTokenInCache();
        })
            .then(function () {
            return _this.accessToken;
        });
    };
    Connector.prototype.refreshAndPersistToken = function () {
        var _this = this;
        return this.refreshAccessToken()
            .then(function () {
            return _this.putAccessTokenInCache();
        })
            .then(function () {
            return _this.accessToken;
        });
    };
    Connector.prototype.refreshAccessToken = function () {
        var _this = this;
        return validator
            .wrapValidatorsWithPromise(function () {
            validator.isNonEmptyString(_this.refreshToken, 'refresh_token', true);
            validator.isNonEmptyString(_this.refreshUrl, 'refresh_url', true);
        }, CatalystConnectorError)
            .then(function () {
            var _a;
            var request = {
                method: 'POST',
                url: _this.refreshUrl,
                data: (_a = {},
                    _a[constants.GRANT_TYPE] = 'refresh_token',
                    _a[constants.CLIENT_ID] = _this.clientId,
                    _a[constants.CLIENT_SECRET] = _this.clientSecret,
                    _a[constants.REFRESH_TOKEN] = _this.refreshToken,
                    _a)
            };
            return _this.requester.send(request);
        })
            .then(function (resp) {
            var tokenObject = resp.data;
            return validator
                .wrapValidatorsWithPromise(function () {
                validator.isNonNullObject(tokenObject, 'auth_response', true);
                validator.validateObject(tokenObject, [constants.ACCESS_TOKEN, constants.EXPIRES_IN], 'auth_response', true);
            }, CatalystConnectorError)
                .then(function () { return tokenObject; });
        })
            .then(function (authResponse) {
            _this.accessToken = authResponse[constants.ACCESS_TOKEN];
            _this.expiresIn = authResponse[constants.EXPIRES_IN];
        });
    };
    Connector.prototype.putAccessTokenInCache = function () {
        return this.app.cache().segment().put(this._connectorName, this.accessToken, 1);
    };
    Object.defineProperty(Connector.prototype, "_connectorName", {
        get: function () {
            return 'ZC_CONN_' + this.connectorName;
        },
        enumerable: false,
        configurable: true
    });
    return Connector;
}(CatalystAppInternals));
exports.Connector = Connector;
