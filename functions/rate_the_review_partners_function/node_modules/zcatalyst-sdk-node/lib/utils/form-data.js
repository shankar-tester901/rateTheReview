'use strict';
var combinedStream = require('combined-stream');
var util = require('util');
var path = require('path');
/**
 * Create readable "multipart/form-data" streams.
 * and file uploads to other web applications.
 *
 * @constructor
 */
var FormData = /** @class */ (function () {
    function FormData() {
        combinedStream.call(this);
    }
    FormData.prototype._multiPartHeader = function (field, value) {
        var contentDisposition = this._getContentDisposition(value);
        var contentType = this._getContentType(value);
        var contents = '';
        var headers = {
            // add custom disposition as third element or keep it two elements if not
            'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
            // if no content type. allow it to be empty array
            'Content-Type': [].concat(contentType || [])
        };
        var header;
        for (var prop in headers) {
            if (!headers.hasOwnProperty(prop)) {
                continue;
            }
            header = headers[prop];
            // skip nullish headers.
            if (header == null) {
                continue;
            }
            // convert all headers to arrays.
            if (!Array.isArray(header)) {
                header = [header];
            }
            // add non-empty headers.
            if (header.length) {
                contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
            }
        }
        return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function (value) {
        var filename;
        var contentDisposition;
        if (value.name || value.path) {
            // custom filename take precedence
            // formidable and the browser add a name property
            // fs- and request- streams have path property
            filename = path.basename(value.name || value.path);
        }
        else if (value.readable && value.hasOwnProperty('httpVersion')) {
            // or try http response
            filename = path.basename(value.client._httpMessage.path || '');
        }
        if (filename) {
            contentDisposition = 'filename="' + filename + '"';
        }
        return contentDisposition;
    };
    FormData.prototype._getContentType = function (value) {
        var contentType;
        // if it's http-reponse
        if (value.readable && value.hasOwnProperty('httpVersion')) {
            contentType = value.headers['content-type'];
        }
        // fallback to the default content type if `value` is not simple value
        if (!contentType) {
            contentType = FormData.DEFAULT_CONTENT_TYPE;
        }
        return contentType;
    };
    FormData.prototype._multiPartFooter = function () {
        return function (next) {
            var footer = FormData.LINE_BREAK;
            var lastPart = this._streams.length === 0;
            if (lastPart) {
                footer += this._lastBoundary();
            }
            next(footer);
        }.bind(this);
    };
    FormData.prototype._lastBoundary = function () {
        return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
    };
    FormData.prototype._generateBoundary = function () {
        // This generates a 50 character boundary similar to those used by Firefox.
        // They are optimized for boyer-moore parsing.
        var boundary = '--------------------------';
        for (var i = 0; i < 24; i++) {
            boundary += Math.floor(Math.random() * 10).toString(16);
        }
        this._boundary = boundary;
    };
    FormData.prototype._error = function (err) {
        if (!this.error) {
            this.error = err;
            this.pause();
            this.emit('error', err);
        }
    };
    FormData.prototype.append = function (field, value) {
        var append = combinedStream.prototype.append.bind(this);
        // all that streamy business can't handle numbers
        if (typeof value === 'number') {
            value = '' + value;
        }
        if (Array.isArray(value)) {
            // Please convert your array into string
            // the way web server expects it
            this._error(new Error('Arrays are not supported.'));
            return;
        }
        append(this._multiPartHeader(field, value));
        append(value);
        append(this._multiPartFooter());
    };
    FormData.prototype.getHeaders = function (userHeaders) {
        var header;
        var formHeaders = {
            'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
        };
        for (header in userHeaders) {
            if (userHeaders.hasOwnProperty(header)) {
                formHeaders[header.toLowerCase()] = userHeaders[header];
            }
        }
        return formHeaders;
    };
    FormData.prototype.getBoundary = function () {
        if (!this._boundary) {
            this._generateBoundary();
        }
        return this._boundary;
    };
    FormData.prototype.toString = function () {
        return '[object FormData]';
    };
    return FormData;
}());
FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
util.inherits(FormData, combinedStream);
module.exports = FormData;
