'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CatalystApiError = require('./error').CatalystApiError;
var querystring = require('querystring');
var http = require('http');
var https = require('https');
var parse = require('url').parse;
var URL = require('url').URL;
var stringify = require('querystring').stringify;
var AUTH_HEADER = require('./constants').AUTH_HEADER;
var COOKIE_HEADER = require('./constants').COOKIE_HEADER;
var PROJECT_KEY_NAME = require('./constants').PROJECT_KEY_NAME;
var ENVIRONMENT_KEY_NAME = require('./constants').ENVIRONMENT_KEY_NAME;
var USER_KEY_NAME = require('./constants').USER_KEY_NAME;
var CREDENTIAL_USER = require('./constants').CREDENTIAL_USER;
var CATALYST_ORIGIN = require('./constants').CATALYST_ORIGIN;
var RequestAgent = require('./request-agent').RequestAgent;
var DefaultHttpResponse = /** @class */ (function () {
    function DefaultHttpResponse(resp) {
        this.status = resp.status;
        this.headers = resp.headers;
        this.text = resp.data;
        this.buffer = resp.buffer;
        try {
            this.parsedData = JSON.parse(resp.data);
        }
        catch (err) {
            this.parsedData = undefined;
            this.parseError = err;
        }
    }
    Object.defineProperty(DefaultHttpResponse.prototype, "data", {
        get: function () {
            if (typeof this.parsedData !== 'undefined') {
                return this.parsedData;
            }
            if (this.text === '') {
                throw new CatalystApiError('empty_response', 'Empty response recevied from server. Raw server ' +
                    ("response: \"" + this.text + "\". Status code: \"" + this.status + "\"."));
            }
            throw new CatalystApiError('unparsable_response', "Error while parsing response data: \"" + this.parseError.toString() + "\". Raw server " +
                ("response: \"" + this.text + "\". Status code: \"" + this.status + "\"."), resp);
        },
        enumerable: false,
        configurable: true
    });
    return DefaultHttpResponse;
}());
function _finalizeRequest(resolve, reject, response) {
    if (response.status >= 200 && response.status < 300) {
        resolve(response);
    }
    else {
        reject('Request failed with status ' +
            response.status +
            ' and code : ' +
            JSON.parse(response.data).data.error_code +
            ' , message : ' +
            JSON.parse(response.data).data.message);
    }
}
function _appendQueryData(path, data) {
    if (data && Object.keys(data).length > 0) {
        path += path.includes('?') ? '&' : '?';
        path += stringify(data);
    }
    return path;
}
function _request(transport, options, data, config) {
    return new Promise(function (resolve, reject) {
        var req = transport.request(options, function (res) {
            if (req.aborted) {
                return;
            }
            // Uncompress the response body transparently if required.
            var respStream = res;
            var response = {
                status: res.statusCode,
                headers: res.headers,
                request: req,
                data: undefined,
                buffer: undefined,
                config: config
            };
            var responseBuffer = [];
            respStream.on('data', function (chunk) {
                responseBuffer.push(chunk);
            });
            respStream.on('error', function (err) {
                if (req.aborted) {
                    return;
                }
                reject(err, config);
            });
            respStream.on('end', function () {
                var responseData = Buffer.concat(responseBuffer);
                response.data = responseData.toString();
                response.buffer = responseData;
                _finalizeRequest(resolve, reject, response);
            });
        });
        // Handle errors
        req.on('error', function (err) {
            if (req.aborted) {
                return;
            }
            reject(err, config);
        });
        // Send the request
        if (config.type === 'file') {
            config.data.pipe(req).on('finish', function () {
                req.end();
            });
        }
        else if (data) {
            req.write(data);
            req.end();
        }
        else {
            req.end();
        }
    });
}
function sendRequest(config) {
    var data;
    var headers = Object.assign({}, config.headers);
    if (config.data) {
        if (config.type && config.type === 'skip') {
            data = config.data;
        }
        else if (config.type && config.type === 'json') {
            data = JSON.stringify(config.data);
            headers['Content-Type'] = 'application/json';
        }
        else if (config.type && config.type === 'file') {
            data = config.data;
            headers = Object.assign(headers, data.getHeaders());
        }
        else {
            data = querystring.stringify(config.data);
            headers['Content-Type'] = 'application/x-www-form-urlencoded';
            headers['Content-Length'] = Buffer.byteLength(data);
        }
    }
    if (config.qs) {
        config.path = _appendQueryData(config.path, config.qs);
    }
    var origin = config.origin || CATALYST_ORIGIN;
    config.url = config.url || new URL(config.path, origin).href;
    var parsed = parse(config.url);
    var protocol = parsed.protocol || 'https:';
    var isHttps = protocol === 'https:';
    var transport = isHttps ? https : http;
    var agent = new RequestAgent(protocol, parsed.hostname, false).agent;
    var options = {
        hostname: parsed.hostname,
        port: parsed.port,
        path: parsed.path,
        method: config.method,
        headers: headers,
        agent: agent
    };
    return _request(transport, options, data, config);
}
var HttpClient = /** @class */ (function () {
    function HttpClient(app) {
        this.app = app;
    }
    HttpClient.prototype.send = function (config) {
        var requestConf = Object.assign({}, config);
        requestConf.headers = Object.assign({}, config.headers);
        if (this.app !== undefined) {
            requestConf.headers[PROJECT_KEY_NAME] = this.app.projectKey;
            requestConf.headers[ENVIRONMENT_KEY_NAME] = this.app.environment;
            if (this.app.getUser() === CREDENTIAL_USER.admin) {
                requestConf.headers[USER_KEY_NAME] = CREDENTIAL_USER.admin;
            }
        }
        return sendRequest(requestConf)
            .then(function (resp) {
            return new DefaultHttpResponse(resp);
        })
            .catch(function (err) {
            throw new CatalystApiError('request_failure', err, err);
        });
    };
    return HttpClient;
}());
exports.HttpClient = HttpClient;
var AuthorizedHttpClient = /** @class */ (function (_super) {
    __extends(AuthorizedHttpClient, _super);
    /**
     * @param {any} app The app used to fetch access tokens to sign API requests.
     * @constructor
     */
    function AuthorizedHttpClient(app) {
        var _this = _super.call(this, app) || this;
        _this.app = app;
        return _this;
    }
    AuthorizedHttpClient.prototype.send = function (request) {
        var _this = this;
        var requestCopy = Object.assign({}, request);
        requestCopy.headers = Object.assign({}, request.headers);
        return this.app.getToken().then(function (accessTokenObj) {
            if (accessTokenObj === null) {
                requestCopy.headers[COOKIE_HEADER] = _this.app.getCookie();
            }
            else {
                requestCopy.headers[AUTH_HEADER] = accessTokenObj.header;
            }
            return _super.prototype.send.call(_this, requestCopy);
        });
    };
    return AuthorizedHttpClient;
}(HttpClient));
exports.AuthorizedHttpClient = AuthorizedHttpClient;
